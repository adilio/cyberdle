<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Cyberdle</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="style.css">
    <script src="acronyms.js"></script>

    <!-- Social preview -->
    <meta property="og:title" content="Cyberdle">
    <meta property="og:description" content="A Wordle style cybersecurity acronym challenge. Learn as you play.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://adilio.github.io/cyberdle/">
    <meta property="og:image" content="https://adilio.github.io/cyberdle/favicon.svg">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Cyberdle">
    <meta name="twitter:description" content="Guess the acronym, learn the craft.">
    <meta name="twitter:image" content="https://adilio.github.io/cyberdle/favicon.svg">

    <!-- Cloudflare Web Analytics (replace YOUR_TOKEN_HERE) -->
    <script defer src="https://static.cloudflareinsights.com/beacon.min.js"
            data-cf-beacon='{"token":"YOUR_TOKEN_HERE"}'></script>

  </head>
  <body>
    <div class="app">
      <header class="app__header">
        <div class="title">
          <h1>
            <img src="favicon.svg" alt="" class="favicon-icon" />
            Cyberdle
          </h1>
          <p>A Wordle-style Cybersecurity Acronym Challenge</p>
        </div>
        <nav class="actions" aria-label="Primary">
          <button type="button" id="help-btn" class="btn btn--ghost">Help</button>
          <button type="button" id="stats-btn" class="btn btn--ghost">Stats</button>
          <button type="button" id="theme-btn" class="btn">Toggle theme</button>
        </nav>
      </header>

      <section class="controls">
        <button type="button" id="play-btn" class="btn btn--accent">Play</button>
        <button type="button" id="test-input-btn" class="btn" onclick="window.CYBERDLE._testInput()" style="margin-left: 0.5rem;">Debug Input</button>
        <div class="controls__meta" role="status" aria-live="polite">
          <span id="puzzle-label"></span>
          <span id="puzzle-date"></span>
        </div>
        <div class="mode-toggle" role="radiogroup" aria-label="Puzzle mode">
          <button type="button" data-mode="daily" class="chip">Daily</button>
          <button type="button" data-mode="random" class="chip">Random</button>
        </div>
        <button type="button" id="hint-btn" class="btn btn--ghost">Hint</button>
        <span id="streak-flair" class="streak-flair" aria-live="polite"></span>

        <label class="chip" style="margin-top:.5rem; display:inline-flex; align-items:center; gap:.5rem;">
          <input type="checkbox" id="strict-toggle"> Strict dictionary
        </label>
      </section>

      <section class="definition" aria-live="polite">
        <h2>Definition</h2>
        <p id="definition-text"></p>
      </section>

      <div id="message" class="message" role="status" aria-live="polite" data-testid="message"></div>

      <input
        id="key-capture"
        type="text"
        aria-hidden="true"
        autocomplete="off"
        autocapitalize="characters"
        spellcheck="false"
      />

      <section id="grid" class="grid" role="grid" aria-label="Guess grid" data-testid="grid"></section>

      <section id="keyboard" class="keyboard" aria-label="On-screen keyboard" data-testid="keyboard"></section>

      <section class="scoreboard" aria-label="Player stats">
        <div class="score">
          <span class="score__label">Score</span>
          <span id="score-total" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Played</span>
          <span id="score-played" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Wins</span>
          <span id="score-won" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Streak</span>
          <span id="score-streak" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Best</span>
          <span id="score-best" class="score__value">0</span>
        </div>
      </section>

      <footer class="footer">
        <div class="footer__instructions"></div>
        <div class="footer__attribution">
          <div><a href="https://github.com/adilio/cyberdle" target="_blank" rel="noopener" class="footer__link">View on GitHub</a></div>
          <div>Made with 💜 by <a href="https://github.com/adilio" target="_blank" rel="noopener" class="footer__link">Adil Leghari</a></div>
        </div>
      </footer>
    </div>

    <dialog id="help-dialog" class="modal">
      <form method="dialog">
        <header class="modal__header">
          <h2>How to play</h2>
          <button class="btn btn--ghost" value="cancel">Close</button>
        </header>
        <div class="modal__body">
          <p>Guess the cybersecurity acronym that matches the definition in six tries.</p>
          <ul>
            <li>Letters turn green when correct, yellow when present elsewhere, gray otherwise.</li>
            <li>Only approved acronyms are accepted. Length must match the target.</li>
            <li>Daily mode picks a deterministic acronym; Random gives a new puzzle each time.</li>
          </ul>
        </div>
      </form>
    </dialog>

    <div id="confetti" aria-hidden="true"></div>

    <dialog id="stats-dialog" class="modal">
      <form method="dialog">
        <header class="modal__header">
          <h2>Statistics</h2>
          <button class="btn btn--ghost" value="cancel">Close</button>
        </header>
        <div class="modal__body">
          <p><strong>Score:</strong> <span id="modal-score">0</span></p>
          <p><strong>Played:</strong> <span id="modal-played">0</span></p>
          <p><strong>Win %:</strong> <span id="modal-win-percent">0</span></p>
          <p><strong>Current streak:</strong> <span id="modal-streak">0</span></p>
          <p><strong>Best streak:</strong> <span id="modal-best">0</span></p>
          <h3 style="margin-top:1rem;">Badges</h3>
          <ul id="badge-list" class="badge-list"></ul>
        </div>
      </form>
    </dialog>

    <div id="result-dialog" class="modal modal--result" role="dialog" aria-modal="true" aria-hidden="true" tabindex="-1">
      <div class="modal__surface">
        <header class="modal__header">
          <h2 id="result-title">Nice work!</h2>
          <button type="button" class="btn btn--ghost" data-close-result>Close</button>
        </header>
        <div class="modal__body">
          <p id="result-message"></p>
          <p><strong>Acronym:</strong> <span id="result-word"></span></p>
          <p><strong>Expansion:</strong> <span id="result-expansion"></span></p>
          <p><strong>Definition:</strong> <span id="result-definition"></span></p>
          <div class="modal__actions">
            <button type="button" class="btn" id="result-share">Share</button>
            <button type="button" class="btn" id="result-copy">Copy result</button>
            <button type="button" class="btn" id="result-challenge">Challenge a friend</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      let dataset = [];
      let wordList = [];

      const SCORE_TABLE = [100, 80, 60, 40, 20, 10];
      const MAX_ATTEMPTS = 6;
      const STORAGE_KEYS = {
        game: 'cyberdle:simple:game',
        stats: 'cyberdle:simple:stats',
        theme: 'cyberdle:simple:theme',
        mode: 'cyberdle:simple:mode'
      };

      const root = document.documentElement;
      const gridEl = document.getElementById('grid');
      const messageEl = document.getElementById('message');
      const definitionEl = document.getElementById('definition-text');
      const puzzleLabelEl = document.getElementById('puzzle-label');
      const puzzleDateEl = document.getElementById('puzzle-date');
      const scoreTotalEl = document.getElementById('score-total');
      const scorePlayedEl = document.getElementById('score-played');
      const scoreWonEl = document.getElementById('score-won');
      const scoreStreakEl = document.getElementById('score-streak');
      const scoreBestEl = document.getElementById('score-best');
      const modalScoreEl = document.getElementById('modal-score');
      const modalPlayedEl = document.getElementById('modal-played');
      const modalWinPercentEl = document.getElementById('modal-win-percent');
      const modalStreakEl = document.getElementById('modal-streak');
      const modalBestEl = document.getElementById('modal-best');
      const helpDialog = document.getElementById('help-dialog');
      const statsDialog = document.getElementById('stats-dialog');
      const resultDialog = document.getElementById('result-dialog');
      const resultTitleEl = document.getElementById('result-title');
      const resultMessageEl = document.getElementById('result-message');
      const resultWordEl = document.getElementById('result-word');
      const resultExpansionEl = document.getElementById('result-expansion');
      const resultDefinitionEl = document.getElementById('result-definition');
      const resultPlayAgainBtn = document.getElementById('result-play-again');
      const resultCloseBtn = document.querySelector('[data-close-result]');
      const themeBtn = document.getElementById('theme-btn');
      const confettiRoot = document.getElementById('confetti');
      const helpBtn = document.getElementById('help-btn');
      const statsBtn = document.getElementById('stats-btn');
      const playBtn = document.getElementById('play-btn');
      const modeButtons = Array.from(document.querySelectorAll('.mode-toggle .chip'));
      const keyboardEl = document.getElementById('keyboard');
      const keyCapture = document.getElementById('key-capture');

      let tiles = [];
      let currentGuess = '';
      let mode = loadMode();
      let stats = loadStats();
      let theme = loadTheme();
      let session = null;
      const keyboardButtons = new Map();
      const keyboardState = new Map();
      let confettiTimeout = 0;
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      initApp();

      async function initApp() {
        console.log('Initializing app...');
        const acronyms = await loadDataset();
        if (!acronyms.length) {
          showDatasetError();
          return;
        }

        dataset = acronyms.map((item) => ({
          word: item.w.toUpperCase(),
          expansion: item.e,
          definition: item.d
        }));
        wordList = dataset.map((item) => item.word);

        session = initSession();
        console.log('Session initialized:', session);
        applyTheme();
        buildGrid(session.len);
        buildKeyboard();
        renderAll();
        attachEvents();
        if ('ontouchstart' in window) {
          tiles.flat().forEach(tile => tile.setAttribute('tabindex', '0'));
        }
        focusKeyCapture();
        console.log('App initialization complete');
      }

      function scoreFor(row) {
        return SCORE_TABLE[row - 1] ?? 0;
      }

      function evaluateGuess(target, guess) {
        const t = [...target];
        const g = [...guess];
        const res = Array(t.length).fill('absent');
        const rem = {};
        for (let i = 0; i < t.length; i += 1) {
          if (g[i] === t[i]) {
            res[i] = 'correct';
          } else {
            const char = t[i];
            rem[char] = (rem[char] ?? 0) + 1;
          }
        }
        for (let i = 0; i < t.length; i += 1) {
          if (res[i] === 'correct') continue;
          const char = g[i];
          if (rem[char] && rem[char] > 0) {
            res[i] = 'present';
            rem[char] -= 1;
          }
        }
        return res;
      }

      function isValidGuess(guess, list, len) {
        return /^[A-Z]+$/.test(guess) && guess.length === len;
      }

      function yyyymmddSeed(date = new Date()) {
        return date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
      }

      function seededIndex(seed, max) {
        let x = seed | 0;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        return Math.abs(x) % max;
      }

      function initSession() {
        const stored = loadGame(wordList);
        if (stored) {
          const entry = dataset[stored.index] || dataset.find((item) => item.word === stored.word);
          if (entry) {
            if (stored.mode === 'daily') {
              const daily = getDailyPuzzle();
              if (entry.word === daily.entry.word) {
                return hydrateSession(stored, entry, daily.seed, daily.index);
              }
            } else {
              return hydrateSession(stored, entry, stored.seed, stored.index);
            }
          }
        }
        return createSessionFromPuzzle(mode === 'daily' ? getDailyPuzzle() : getRandomPuzzle(), mode);
      }

      function hydrateSession(stored, entry, seed, index) {
        mode = stored.mode;
        const guesses = stored.guesses.slice(0, MAX_ATTEMPTS).map((x) => x.toUpperCase());
        const results = stored.results.slice(0, MAX_ATTEMPTS);
        return {
          word: entry.word,
          expansion: entry.expansion,
          definition: entry.definition,
          len: entry.word.length,
          guesses,
          results,
          row: Math.max(0, Math.min(MAX_ATTEMPTS - 1, stored.row)),
          done: Boolean(stored.done),
          win: Boolean(stored.win),
          seed,
          index,
          mode
        };
      }

      function createSession(entry, puzzleMode, index, seed) {
        return {
          word: entry.word,
          expansion: entry.expansion,
          definition: entry.definition,
          len: entry.word.length,
          guesses: Array(MAX_ATTEMPTS).fill(''),
          results: Array(MAX_ATTEMPTS).fill(null),
          row: 0,
          done: false,
          win: false,
          seed,
          index,
          mode: puzzleMode
        };
      }

      function getDailyPuzzle() {
        const seed = yyyymmddSeed();
        const index = seededIndex(seed, dataset.length);
        return { entry: dataset[index], index, seed };
      }

      function getRandomPuzzle() {
        const seed = Math.floor(Math.random() * 2 ** 31);
        const index = Math.floor(Math.random() * dataset.length);
        return { entry: dataset[index], index, seed };
      }

      function createSessionFromPuzzle(puzzle, puzzleMode) {
        mode = puzzleMode;
        saveMode(mode);
        stats = loadStats();
        const next = createSession(puzzle.entry, puzzleMode, puzzle.index, puzzle.seed);
        persistSession(next);
        return next;
      }

      function persistSession(state) {
        saveGame({
          version: 1,
          word: state.word,
          definition: state.definition,
          len: state.len,
          guesses: state.guesses,
          results: state.results.map((row) => (row ? [...row] : [])),
          row: state.row,
          done: state.done,
          win: state.win,
          seed: state.seed,
          index: state.index,
          mode: state.mode
        });
      }

      function buildGrid(columns) {
        root.style.setProperty('--cols', String(columns));
        gridEl.innerHTML = '';
        tiles = [];
        for (let row = 0; row < MAX_ATTEMPTS; row += 1) {
          const rowEl = document.createElement('div');
          rowEl.className = 'grid__row';
          rowEl.setAttribute('role', 'row');
          const rowTiles = [];
          for (let col = 0; col < columns; col += 1) {
            const tile = document.createElement('div');
            tile.className = 't';
            tile.setAttribute('role', 'gridcell');
            rowEl.appendChild(tile);
            rowTiles.push(tile);
          }
          gridEl.appendChild(rowEl);
          tiles.push(rowTiles);
        }
      }

      function buildKeyboard() {
        if (!keyboardEl) return;
        keyboardButtons.clear();
        keyboardEl.innerHTML = '';
        const layout = [
          ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
          ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
          ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACK']
        ];
        layout.forEach((row) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'keyboard__row';
          row.forEach((key) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'key';
            if (key === 'ENTER') {
              button.dataset.key = 'ENTER';
              button.textContent = 'Enter';
              button.classList.add('key--wide');
            } else if (key === 'BACK') {
              button.dataset.key = 'BACK';
              button.textContent = '⌫';
              button.classList.add('key--wide');
            } else {
              button.dataset.key = key;
              button.textContent = key;
              keyboardButtons.set(key, button);
            }
            rowEl.appendChild(button);
          });
          keyboardEl.appendChild(rowEl);
        });
        keyboardState.clear();
      }

      function renderAll() {
        renderModeButtons();
        renderDefinition();
        renderGrid();
        renderStats();
        updateModalStats();
        updateMeta();
        updateFooter();
        setMessage('');
      }

      function renderModeButtons() {
        modeButtons.forEach((button) => {
          const value = button.dataset.mode === 'random' ? 'random' : 'daily';
          button.dataset.active = value === mode ? 'true' : 'false';
        });
      }

      function renderDefinition() {
        definitionEl.textContent = session.definition;
      }

      function renderGrid() {
        tiles.forEach((rowEl, rowIndex) => {
          const rowContainer = rowEl[0] ? rowEl[0].parentElement : null;
          if (rowContainer) {
            rowContainer.classList.toggle('active', !session.done && session.row === rowIndex);
          }
          rowEl.forEach((tile, colIndex) => {
            const guessLetter = session.guesses[rowIndex]?.[colIndex] ?? '';
            tile.textContent = guessLetter;
            tile.classList.remove('t--correct', 't--present', 't--absent');
            const resultRow = session.results[rowIndex];
            const status = resultRow ? resultRow[colIndex] : undefined;
            if (status === 'correct') tile.classList.add('t--correct');
            else if (status === 'present') tile.classList.add('t--present');
            else if (status === 'absent') tile.classList.add('t--absent');
          });
        });
        if (!session.done) {
          const rowIndex = session.row;
          tiles[rowIndex].forEach((tile, colIndex) => {
            tile.textContent = currentGuess[colIndex] ?? '';
          });
        }
        refreshKeyboardFromSession();
      }

      function renderStats() {
        scoreTotalEl.textContent = String(stats.score);
        scorePlayedEl.textContent = String(stats.played);
        scoreWonEl.textContent = String(stats.won);
        scoreStreakEl.textContent = String(stats.streak);
        scoreBestEl.textContent = String(stats.best);
      }

      function updateModalStats() {
        modalScoreEl.textContent = String(stats.score);
        modalPlayedEl.textContent = String(stats.played);
        const winPercent = stats.played === 0 ? 0 : Math.round((stats.won / stats.played) * 100);
        modalWinPercentEl.textContent = String(winPercent);
        modalStreakEl.textContent = String(stats.streak);
        modalBestEl.textContent = String(stats.best);
      }

      function updateMeta() {
        puzzleLabelEl.textContent = `Puzzle #${session.index + 1}`;
        puzzleDateEl.textContent = mode === 'daily' ? new Date().toLocaleDateString() : 'Random challenge';
      }

      function updateFooter() {
        const instructionsEl = document.querySelector('.footer__instructions');
        if (!instructionsEl) return;
        const isTouch = 'ontouchstart' in window;
        instructionsEl.textContent = isTouch
          ? 'Use the on-screen keyboard or type in the input below. Enter submits.'
          : 'Type with your keyboard. Enter submits. Backspace deletes.';
      }

      function setMessage(message, tone = 'info') {
        messageEl.textContent = message;
        messageEl.dataset.tone = tone;
      }

      function attachEvents() {
        console.log('Attaching events...');

        // Simplified input handling for debugging
        keyCapture.addEventListener('input', (event) => {
          console.log('Input event fired:', event.target.value);
          if (!session) {
            console.error('No session in input handler');
            return;
          }

          const newValue = event.target.value.toUpperCase();
          const allowedLength = session.len;

          // Simple approach: only allow valid characters and length
          const filtered = newValue.replace(/[^A-Z]/g, '').substring(0, allowedLength);

          if (filtered !== currentGuess) {
            currentGuess = filtered;
            renderGrid();
            console.log('Updated guess:', currentGuess);
          }

          // Keep input in sync
          event.target.value = currentGuess;
        });

        // Keep existing keyboard click handling
        const isTouch = 'ontouchstart' in window;
        if (isTouch && gridEl) {
          gridEl.addEventListener('click', (event) => {
            if (event.target.classList.contains('t') && !session.done) {
              focusKeyCapture();
            }
          });
        } else if (!isTouch) {
          window.addEventListener('keydown', handleKeydown);
        }

        // Add Enter key support to input
        keyCapture.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            submitGuess();
          }
        });
        if (themeBtn) themeBtn.addEventListener('click', handleThemeToggle);
        if (helpBtn && helpDialog) helpBtn.addEventListener('click', () => helpDialog.showModal());
        if (statsBtn && statsDialog) {
          statsBtn.addEventListener('click', () => {
            updateModalStats();
            statsDialog.showModal();
          });
        }
        if (helpDialog) helpDialog.addEventListener('close', focusKeyCapture);
        if (statsDialog) statsDialog.addEventListener('close', focusKeyCapture);
        if (resultCloseBtn) {
          resultCloseBtn.addEventListener('click', () => {
            forceCloseResultDialog();
          });
        }
        if (resultDialog) {
          const resultSurface = resultDialog.querySelector('.modal__surface');
          if (resultSurface) {
            resultSurface.addEventListener('click', (event) => event.stopPropagation());
          }
          resultDialog.addEventListener('click', (event) => {
            if (event.target === resultDialog) {
              forceCloseResultDialog();
            }
          });
        }
        // Attach keyboard events after keyboard is built
        setTimeout(() => {
          if (keyboardEl) {
            keyboardEl.addEventListener('click', handleKeyboardClick);
          } else {
            console.warn('Keyboard element not found for click events');
          }
        }, 200);
        if (playBtn) playBtn.addEventListener('click', () => startNewGame(mode));
        if (modeButtons) {
          modeButtons.forEach((button) => {
            button.addEventListener('click', () => {
              const nextMode = button.dataset.mode === 'random' ? 'random' : 'daily';
              if (mode === nextMode) return;
              mode = nextMode;
              saveMode(mode);
              startNewGame(mode);
              renderModeButtons();
            });
          });
        }
        if (resultPlayAgainBtn) {
          resultPlayAgainBtn.addEventListener('click', () => {
            forceCloseResultDialog();
            startNewGame(mode);
          });
        }
        keyCapture.addEventListener('blur', focusKeyCapture);
      }

      async function loadDataset() {
        if (Array.isArray(window.CYBERDLE_DATA)) {
          return window.CYBERDLE_DATA;
        }
        console.error('CYBERDLE_DATA not found – ensure acronyms.js loads before index.html.');
        return [];
      }

      function launchConfetti() {
        if (!confettiRoot || prefersReducedMotion) return;

        stopConfetti();
        const colors = ['#00cc66', '#ffd966', '#0f9347', '#65e088'];
        const total = 140;
        const frag = document.createDocumentFragment();

        for (let i = 0; i < total; i += 1) {
          const piece = document.createElement('span');
          piece.className = 'confetti-piece';
          piece.style.left = `${Math.random() * 100}%`;
          piece.style.setProperty('--dx', `${(Math.random() - 0.5) * 40}vw`);
          piece.style.setProperty('--rot', `${Math.random() * 720 - 360}deg`);
          piece.style.setProperty('--dur', `${1.2 + Math.random() * 0.6}s`);
          piece.style.setProperty('--delay', `${Math.random() * 0.2}s`);
          piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          frag.appendChild(piece);
        }

        confettiRoot.appendChild(frag);
        confettiRoot.dataset.active = 'true';

        confettiTimeout = window.setTimeout(() => stopConfetti(), 1800);
      }

      function stopConfetti() {
        if (!confettiRoot) return;
        window.clearTimeout(confettiTimeout);
        confettiRoot.dataset.active = 'false';
        confettiRoot.innerHTML = '';
      }

      function forceCloseResultDialog() {
        // Remove modal-active class from body and html
        document.documentElement.classList.remove('modal-active');
        document.body.classList.remove('modal-active');

        resultDialog.classList.remove('is-open');
        resultDialog.setAttribute('aria-hidden', 'true');

        // Force hide the modal by setting display to none
        resultDialog.style.display = 'none';

        // Also reset the backdrop opacity using CSS custom properties
        resultDialog.style.setProperty('--modal-backdrop-opacity', '0');
        resultDialog.style.position = '';
        resultDialog.style.inset = '';
        resultDialog.style.top = '';
        resultDialog.style.left = '';
        resultDialog.style.width = '';
        resultDialog.style.height = '';
        resultDialog.style.zIndex = '';
        resultDialog.style.justifyContent = '';
        resultDialog.style.alignItems = '';
        resultDialog.style.background = '';
        resultDialog.style.boxSizing = '';

        // Also try to close using native dialog method
        try {
          if (resultDialog.close) {
            resultDialog.close();
          }
        } catch (e) {
          // Ignore errors if dialog is already closed
        }

        stopConfetti();
        focusKeyCapture();
      }

      function showDatasetError() {
        setMessage('Unable to load the acronym list. Ensure `acronyms.js` sits next to `index.html`.', 'error');
        definitionEl.textContent = 'Missing dataset file.';
        puzzleLabelEl.textContent = '';
        puzzleDateEl.textContent = '';
        gridEl.innerHTML = '';
        keyboardEl.innerHTML = '';
        [playBtn, themeBtn, helpBtn, statsBtn, resultPlayAgainBtn, ...modeButtons].forEach((el) => {
          if (el) el.disabled = true;
        });
      }

      function focusKeyCapture() {
        if (!session.done) {
          // Ensure input is properly set for mobile
          keyCapture.value = currentGuess || ' ';
          keyCapture.focus({ preventScroll: true });
          // Set cursor to end for better UX
          setTimeout(() => {
            const pos = keyCapture.value.length;
            keyCapture.setSelectionRange(pos, pos);
          }, 0);
        }
      }

      function handleThemeToggle() {
        theme = theme === 'dark' ? 'light' : 'dark';
        applyTheme();
        saveTheme(theme);
      }

      function applyTheme() {
        root.setAttribute('data-theme', theme);
      }

      function handleKeydown(event) {
        if (statsDialog.open || helpDialog.open) return;

        if (session.done && event.key === 'Enter') {
          forceCloseResultDialog();
          startNewGame(mode);
          return;
        }

        if (event.key === 'Enter') {
          submitGuess();
        } else if (event.key === 'Backspace') {
          removeLetter();
        } else {
          const letter = event.key.toUpperCase();
          if (/^[A-Z]$/.test(letter)) {
            addLetter(letter);
          }
        }
      }

      // Simplified input handling - using basic input event only

      function handleKeyboardClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLButtonElement)) return;
        const key = target.dataset.key;
        if (!key) return;
        if (key === 'ENTER') {
          submitGuess();
        } else if (key === 'BACK') {
          removeLetter();
        } else {
          addLetter(key);
        }
        focusKeyCapture();
      }

      function addLetter(letter) {
        if (!session) {
          console.error('Session not initialized');
          return;
        }
        if (session.done) return;
        if (currentGuess.length < session.len) {
          currentGuess += letter;
          renderGrid();
        }
      }

      function removeLetter() {
        if (session.done) return;
        currentGuess = currentGuess.slice(0, -1);
        renderGrid();
      }

      function submitGuess() {
        if (session.done) {
          const attempts = session.results.filter(Boolean).length || session.row + 1;
          showResultDialog(session.win, session.win ? attempts : MAX_ATTEMPTS);
          return;
        }
        if (currentGuess.length !== session.len) {
          setMessage('Not enough letters', 'error');
          return;
        }
        if (!isValidGuess(currentGuess, wordList, session.len)) {
          setMessage('Letters only (A–Z).', 'error');
          return;
        }
        handleGuess(currentGuess);
      }

      function handleGuess(guess) {
        const rowIndex = session.row;
        const evaluation = evaluateGuess(session.word, guess);
        session.guesses[rowIndex] = guess;
        session.results[rowIndex] = evaluation;
        updateKeyboardWithGuess(guess, evaluation);
        renderGrid();

        if (evaluation.every((tile) => tile === 'correct')) {
            session.done = true;
            session.win = true;
            stats = applyWin(stats, rowIndex);
            persistSession(session);
            saveStats(stats);
            renderStats();
            updateModalStats();
            setMessage(`Solved in ${rowIndex + 1} ${rowIndex === 0 ? 'try' : 'tries'}!`, 'success');

            // Launch confetti immediately
            launchConfetti();

            // Delay modal appearance to let confetti be visible
            setTimeout(() => {
              showResultDialog(true, rowIndex + 1);
            }, 500); // 0.5 second delay to enjoy the confetti

            return;
          }

        if (rowIndex === MAX_ATTEMPTS - 1) {
          session.done = true;
          session.win = false;
          stats = applyLoss(stats);
          persistSession(session);
          saveStats(stats);
          renderStats();
          updateModalStats();
          setMessage(`Out of tries! The word was ${session.word}.`, 'error');
          showResultDialog(false, MAX_ATTEMPTS);
          return;
        }

        session.row += 1;
        currentGuess = '';
        persistSession(session);
        renderGrid();
        setMessage('');
      }

      function updateKeyboardWithGuess(guess, evaluation) {
        guess.split('').forEach((letter, index) => {
          const next = evaluation[index];
          const merged = mergeTileState(keyboardState.get(letter), next);
          keyboardState.set(letter, merged);
          const button = keyboardButtons.get(letter);
          if (button) {
            button.dataset.state = merged;
          }
        });
      }

      function refreshKeyboardFromSession() {
        keyboardButtons.forEach((button) => {
          delete button.dataset.state;
        });
        keyboardState.clear();
        session.results.forEach((result, idx) => {
          if (!result) return;
          const guess = session.guesses[idx];
          if (!guess) return;
          updateKeyboardWithGuess(guess, result);
        });
      }

      function mergeTileState(previous, next) {
        if (!previous) return next;
        const priority = { correct: 3, present: 2, absent: 1 };
        return priority[next] >= priority[previous] ? next : previous;
      }

      const WIN_TITLES = [
        'You cracked it!',
        'Cyber sleuth!',
        'Mission accomplished!',
        'Zero-day wizardry!',
        'Security star!',
        'Threat neutralized!',
        'Legendary analyst!',
        'Perimeter breached!',
        'Firewall of fame!',
        'Acronym assassin!',
        'Defense in depth master!',
        'SOC hero!',
        'Crypto champ!',
        'Nailed the signal!',
        'Own the incident!'
      ];

      function randomWinTitle() {
        if (!WIN_TITLES.length) return 'You cracked it!';
        const now = Date.now();
        const idx = Math.abs((now ^ (now >>> 7) ^ (now << 3))) % WIN_TITLES.length;
        return WIN_TITLES[idx];
      }

      function showResultDialog(win, attempts) {
        resultTitleEl.textContent = win ? randomWinTitle() : 'Good effort!';
        resultMessageEl.textContent = win
          ? `Solved in ${attempts} ${attempts === 1 ? 'try' : 'tries'}.`
          : `The answer was ${session.word}.`;
        resultWordEl.textContent = session.word;
        resultExpansionEl.textContent = session.expansion;
        resultDefinitionEl.textContent = session.definition;

        document.body.classList.add('modal-active');
        resultDialog.classList.add('is-open');
        resultDialog.setAttribute('aria-hidden', 'false');

        // Use native dialog method with fallback
        try {
          resultDialog.showModal();
        } catch (e) {
          // Fallback for browsers that don't support showModal
          resultDialog.style.display = 'flex';
          resultDialog.style.position = 'fixed';
          resultDialog.style.inset = '0';
          resultDialog.style.width = '100vw';
          resultDialog.style.height = '100vh';
          resultDialog.style.zIndex = '999999';
          resultDialog.style.justifyContent = 'center';
          resultDialog.style.alignItems = 'center';
          resultDialog.style.background = 'transparent';
          resultDialog.style.boxSizing = 'border-box';
        }

        if (resultCloseBtn) {
          setTimeout(() => resultCloseBtn.focus({ preventScroll: true }), 100);
        }
      }

      function applyWin(snapshot, rowIndex) {
        const score = scoreFor(rowIndex + 1);
        return {
          version: 1,
          played: snapshot.played + 1,
          won: snapshot.won + 1,
          streak: snapshot.streak + 1,
          best: Math.max(snapshot.best, snapshot.streak + 1),
          score: snapshot.score + score
        };
      }

      function applyLoss(snapshot) {
        return {
          version: 1,
          played: snapshot.played + 1,
          won: snapshot.won,
          streak: 0,
          best: snapshot.best,
          score: snapshot.score
        };
      }

      function startNewGame(nextMode) {
        // Force close any open modals before starting new game
        forceCloseResultDialog();

        currentGuess = '';
        const puzzle = nextMode === 'daily' ? getDailyPuzzle() : getRandomPuzzle();
        session = createSessionFromPuzzle(puzzle, nextMode);
        buildGrid(session.len);
        buildKeyboard();
        renderAll();
        focusKeyCapture();
      }

      function safeParse(value) {
        if (!value) return null;
        try {
          return JSON.parse(value);
        } catch (error) {
          console.warn('Failed to parse storage value', error);
          return null;
        }
      }

      function loadGame(expectedWordList) {
        if (typeof window === 'undefined') return null;
        const raw = safeParse(localStorage.getItem(STORAGE_KEYS.game));
        if (!raw || raw.version !== 1) return null;
        if (!expectedWordList.includes(raw.word)) return null;
        if (raw.len !== raw.word.length) return null;
        if (!Array.isArray(raw.guesses) || !Array.isArray(raw.results)) return null;
        const guesses = raw.guesses.slice(0, MAX_ATTEMPTS).map((g) => (typeof g === 'string' ? g : ''));
        const results = raw.results.slice(0, MAX_ATTEMPTS).map((row) => (Array.isArray(row) ? row : []));
        return {
          version: 1,
          word: raw.word,
          definition: raw.definition,
          len: raw.len,
          guesses,
          results,
          row: Number.isFinite(raw.row) ? Math.max(0, Math.min(MAX_ATTEMPTS - 1, Math.floor(raw.row))) : 0,
          done: Boolean(raw.done),
          win: Boolean(raw.win),
          seed: Number.isFinite(raw.seed) ? Math.floor(raw.seed) : 0,
          index: Number.isFinite(raw.index) ? Math.floor(raw.index) : 0,
          mode: raw.mode === 'random' ? 'random' : 'daily'
        };
      }

      function saveGame(state) {
        localStorage.setItem(STORAGE_KEYS.game, JSON.stringify(state));
      }

      function loadStats() {
        const raw = safeParse(localStorage.getItem(STORAGE_KEYS.stats));
        if (!raw || raw.version !== 1) return createInitialStats();
        return {
          version: 1,
          played: sanitizeNumber(raw.played),
          won: sanitizeNumber(raw.won),
          streak: sanitizeNumber(raw.streak),
          best: sanitizeNumber(raw.best),
          score: sanitizeNumber(raw.score)
        };
      }

      function saveStats(snapshot) {
        localStorage.setItem(STORAGE_KEYS.stats, JSON.stringify(snapshot));
      }

      function createInitialStats() {
        return { version: 1, played: 0, won: 0, streak: 0, best: 0, score: 0 };
      }

      function sanitizeNumber(value) {
        return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
      }

      function loadTheme() {
        const raw = localStorage.getItem(STORAGE_KEYS.theme);
        return raw === 'light' ? 'light' : 'dark';
      }

      function saveTheme(next) {
        localStorage.setItem(STORAGE_KEYS.theme, next);
      }

      function loadMode() {
        const raw = localStorage.getItem(STORAGE_KEYS.mode);
        return raw === 'random' ? 'random' : 'daily';
      }

      function saveMode(nextMode) {
        localStorage.setItem(STORAGE_KEYS.mode, nextMode);
      }

      /* ============== Deterministic query helpers and flags ============== */
      function getQueryInt(name) {
        const v = new URLSearchParams(location.search).get(name);
        const n = Number(v);
        return Number.isFinite(n) ? Math.floor(n) : null;
      }
      function getForcedIndexFromURL() {
        const n = getQueryInt('puzzle');
        return n != null && n >= 0 && n < dataset.length ? n : null;
      }
      function getForcedSeedFromURL() {
        return getQueryInt('seed');
      }
      function queryHas(name, expected = '1') {
        return new URLSearchParams(location.search).get(name) === expected;
      }

      /* Clear LocalStorage if requested */
      if (typeof localStorage !== 'undefined' && queryHas('reset')) {
        try {
          Object.values(STORAGE_KEYS || {}).forEach(k => localStorage.removeItem(k));
          localStorage.removeItem('cyberdle:simple:strict');
        } catch {}
      }

      /* ============== Mobile input fixes ============== */
      function syncInputMaxLength() {
        if (session && session.len && keyCapture) {
          keyCapture.setAttribute('maxlength', String(session.len));
        }
      }
      function focusKeyCapture() {
        if (!session) {
          console.log('No session to focus');
          return;
        }
        if (!session.done) {
          console.log('Focusing input, current guess:', currentGuess);
          keyCapture.value = currentGuess;
          keyCapture.focus({ preventScroll: true });
          setTimeout(() => {
            const pos = keyCapture.value.length;
            keyCapture.setSelectionRange(pos, pos);
          }, 0);
        }
      }
      /* Input filtering is handled by handleMobileInput function */

      /* VisualViewport padding to keep UI visible when soft keyboard is open */
      (function mountViewportPadding() {
        const vv = window.visualViewport;
        if (!vv) return;
        const apply = () => {
          const overlap = Math.max(0, (window.innerHeight - vv.height));
          document.documentElement.style.setProperty('--kb-pad', overlap > 40 ? (overlap + 8) + 'px' : '0px');
        };
        vv.addEventListener('resize', apply);
        vv.addEventListener('scroll', apply);
        apply();
      })();

      /* Optional haptics on key taps */
      function lightHaptic() { try { navigator.vibrate?.(10); } catch {} }
      function attachHapticFeedback() {
        if (keyboardEl) {
          keyboardEl.addEventListener('click', (e) => {
            if (e.target.closest('.key')) lightHaptic();
          }, { passive: true });
        } else {
          console.warn('Keyboard element not found for haptic feedback');
        }
      }

      /* Keep validation focused on syntax and length only */
      function isValidGuess(guess, list, len) {
        return /^[A-Z]+$/.test(guess) && guess.length === len;
      }

      /* ============== Strict dictionary support ============== */
      const STORAGE_FLAGS = { strict: 'cyberdle:simple:strict' };
      function loadStrict() { return localStorage.getItem(STORAGE_FLAGS.strict) === '1'; }
      function saveStrict(v) { localStorage.setItem(STORAGE_FLAGS.strict, v ? '1' : '0'); }
      const strictToggle = document.getElementById('strict-toggle');
      let strictMode = loadStrict();
      if (strictToggle) strictToggle.checked = strictMode;

      /* ============== Share text and challenge link ============== */
      function resultShareText() {
        const attemptsUsed = session.results.filter(Boolean).length || (session.row + 1);
        const header = `Cyberdle #${session.index + 1} ${session.win ? attemptsUsed : 'X'}/${MAX_ATTEMPTS}`;
        const rows = session.results
          .filter(Boolean)
          .map(row => row.map(s => s === 'correct' ? '🟩' : s === 'present' ? '🟨' : '⬛').join(''))
          .join('\n');
        const url = `${location.origin}${location.pathname}?src=share`;
        return `${header}\n${rows}\n${url}`;
      }
      function challengeLinkForCurrent() {
        return `${location.origin}${location.pathname}?puzzle=${session.index}`;
      }

      /* ============== Hint helper and penalty ============== */
      function hintText() {
        const first = session.word[0];
        const last = session.word[session.word.length - 1];
        const isVowel = (char) => ['A', 'E', 'I', 'O', 'U'].includes(char);
        const firstVowel = session.word.split('').find(isVowel) || first;
        const category = getAcronymCategory(session.word);

        // Provide multiple hint options based on word characteristics
        const hints = [
          `Starts with "${first}"`,
          `Ends with "${last}"`,
          `Contains "${firstVowel}"`
        ];

        if (category) {
          hints.push(`Category: ${category}`);
        }

        return `Hint: ${hints.join(', ')}`;
      }

      function getAcronymCategory(word) {
        const categories = {
          'NETWORK': 'Networking',
          'SECURITY': 'Security',
          'CLOUD': 'Cloud Computing',
          'DATA': 'Data & Storage',
          'WEB': 'Web & Internet',
          'CRYPTO': 'Cryptography',
          'SYSTEM': 'System Administration',
          'DEV': 'Development'
        };

        for (const [key, value] of Object.entries(categories)) {
          if (word.includes(key)) {
            return value;
          }
        }
        return null;
      }

      /* ============== Badges and streak flair ============== */
      function currentBadges() {
        const b = [];
        if (stats.best >= 3) b.push('Streak 3');
        if (stats.best >= 5) b.push('Streak 5');
        if (stats.best >= 10) b.push('Streak 10');
        if (stats.score >= 500) b.push('Score 500');
        if (stats.won >= 10) b.push('10 Wins');
        return b;
      }
      function renderBadges() {
        const ul = document.getElementById('badge-list');
        if (!ul) return;
        const items = currentBadges();
        ul.innerHTML = items.length ? items.map(x => `<li>${x}</li>`).join('') : '<li>Keep playing to earn badges</li>';
      }
      function renderStreakFlair() {
        const el = document.getElementById('streak-flair');
        if (!el) return;
        const s = stats.streak;
        if (s <= 0) { el.textContent = ''; return; }
        const icon = s >= 10 ? '🔥' : s >= 5 ? '⚡' : '⭐';
        el.textContent = `${icon} ${s}-day streak`;
      }

      /* ============== Honor ?puzzle and ?seed in puzzle pickers ============== */
      const _origGetDaily = getDailyPuzzle;
      const _origGetRandom = getRandomPuzzle;
      function getDailyPuzzle() {
        const forced = getForcedIndexFromURL();
        if (forced != null) return { entry: dataset[forced], index: forced, seed: forced };
        return _origGetDaily();
      }
      function getRandomPuzzle() {
        const forced = getForcedIndexFromURL();
        const forcedSeed = getForcedSeedFromURL();
        if (forced != null) return { entry: dataset[forced], index: forced, seed: forcedSeed ?? forced };
        return _origGetRandom();
      }

      /* ============== Bind new UI controls ============== */
      (function attachExtraEvents() {
        const hintBtn = document.getElementById('hint-btn');
        if (hintBtn) {
          hintBtn.addEventListener('click', () => {
            if (session.done) return;
            if (!session.hinted) {
              session.hinted = true;
              persistSession(session);
            }
            setMessage(hintText(), 'info');
            focusKeyCapture();
          });
        }
        if (strictToggle) {
          strictToggle.addEventListener('change', () => {
            strictMode = strictToggle.checked;
            saveStrict(strictMode);
            focusKeyCapture();
          });
        }
        const resultCopyBtn = document.getElementById('result-copy');
        if (resultCopyBtn) {
          resultCopyBtn.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(resultShareText());
              setMessage('Result copied to clipboard', 'success');
            } catch {
              setMessage('Could not copy. Long press to copy manually.', 'error');
            }
          });
        }
        const resultShareBtn = document.getElementById('result-share');
        if (resultShareBtn) {
          resultShareBtn.addEventListener('click', async () => {
            const text = resultShareText();
            if (navigator.share) {
              try { await navigator.share({ text }); return; } catch {}
            }
            try {
              await navigator.clipboard.writeText(text);
              setMessage('Result copied. Paste to share anywhere.', 'success');
            } catch {
              setMessage('Could not share. Long press to copy manually.', 'error');
            }
          });
        }
        const resultChallengeBtn = document.getElementById('result-challenge');
        if (resultChallengeBtn) {
          resultChallengeBtn.addEventListener('click', async () => {
            const link = challengeLinkForCurrent();
            const msg = `Try my Cyberdle: ${link}`;
            if (navigator.share) {
              try { await navigator.share({ text: msg }); return; } catch {}
            }
            try {
              await navigator.clipboard.writeText(link);
              setMessage('Link copied. Send it to a friend.', 'success');
            } catch {
              setMessage('Could not copy. Long press to copy manually.', 'error');
            }
          });
        }
      })();

      /* ============== Score penalty on win ============== */
      const _origApplyWin = applyWin;
      function applyWin(snapshot, rowIndex) {
        const base = scoreFor(rowIndex + 1);
        const penalty = session && session.hinted ? 20 : 0;
        return {
          version: 1,
          played: snapshot.played + 1,
          won: snapshot.won + 1,
          streak: snapshot.streak + 1,
          best: Math.max(snapshot.best, snapshot.streak + 1),
          score: snapshot.score + Math.max(0, base - penalty)
        };
      }

      /* ============== Enhanced submit with strict dictionary ============== */
      function submitGuess() {
        if (!session) {
          console.error('No session in submitGuess');
          return;
        }

        if (session.done) {
          const attempts = session.results.filter(Boolean).length || session.row + 1;
          showResultDialog(session.win, session.win ? attempts : MAX_ATTEMPTS);
          return;
        }

        if (currentGuess.length !== session.len) {
          setMessage('Not enough letters', 'error');
          return;
        }

        if (!isValidGuess(currentGuess, wordList, session.len)) {
          setMessage('Letters only (A–Z).', 'error');
          return;
        }

        if (strictMode && !wordList.includes(currentGuess.toUpperCase())) {
          setMessage('Not in the approved acronym list', 'error');
          return;
        }

        // Process the guess directly
        handleGuess(currentGuess);
      }

      /* ============== Streak flair update and milestone messages ============== */
      const _origHandleGuess = handleGuess;
      function handleGuess(guess) {
        _origHandleGuess(guess);
        renderStreakFlair();
        if (session.done && session.win) {
          if (stats.streak === 5) setMessage('Five days in a row. You are on a roll.', 'success');
          if (stats.streak === 10 || (stats.streak > 0 && stats.streak % 10 === 0)) {
            setMessage(`Amazing, day ${stats.streak}.`, 'success');
          }
          const flair = document.getElementById('streak-flair');
          if (flair) {
            flair.classList.add('streak-hot');
            setTimeout(() => flair.classList.remove('streak-hot'), 900);
          }
        }
      }

      /* ============== Enhanced stats modal update ============== */
      function updateModalStats() {
        modalScoreEl.textContent = String(stats.score);
        modalPlayedEl.textContent = String(stats.played);
        const winPercent = stats.played === 0 ? 0 : Math.round((stats.won / stats.played) * 100);
        modalWinPercentEl.textContent = String(winPercent);
        modalStreakEl.textContent = String(stats.streak);
        modalBestEl.textContent = String(stats.best);

        // Add badges rendering
        renderBadges();
      }

      /* ============== Welcome message for share traffic ============== */
      (function welcomeFromShare() {
        const src = new URLSearchParams(location.search).get('src');
        if (src === 'share') setMessage('Welcome, this puzzle came from a shared result.', 'info');
      })();

      /* ============== Test hooks for the agent ============== */
      window.CYBERDLE = Object.assign(window.CYBERDLE || {}, {
        _evaluateGuess: evaluateGuess,
        _scoreFor: scoreFor,
        _seededIndex: seededIndex,
        _yyyymmddSeed: yyyymmddSeed,
        _mergeTileState: mergeTileState,
        _getSession: () => session,
        _getStats: () => stats,
        _startNewGame: (modeOverride) => startNewGame(modeOverride || mode),
        _clearStorage: () => {
          try {
            Object.values(STORAGE_KEYS).forEach(k => localStorage.removeItem(k));
            localStorage.removeItem('cyberdle:simple:strict');
          } catch {}
        },
        // Debug helpers
        _testInput: () => {
          console.log('Testing input - Session:', session);
          console.log('Current guess:', currentGuess);
          if (session) {
            console.log('Session length:', session.len);
            console.log('Can add letter?', currentGuess.length < session.len);
          }
        },
        _addTestLetter: (letter) => {
          console.log('Adding test letter:', letter);
          addLetter(letter);
          console.log('Result - Current guess:', currentGuess);
        }
      });

      /* Input handling is managed by handleMobileInput */
    </script>
  </body>
</html>
