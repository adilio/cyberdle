<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Cyberdle</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <link rel="stylesheet" href="style.css">
    <script src="acronyms.js"></script>

  </head>
  <body>
    <div class="app">
      <header class="app__header">
        <div class="title">
          <h1>
            <img src="favicon.svg" alt="" class="favicon-icon" />
            Cyberdle
          </h1>
          <p>A Wordle-style Cyber Acronym Game</p>
        </div>
        <nav class="actions" aria-label="Primary">
          <button type="button" id="help-btn" class="btn btn--ghost">Help</button>
          <button type="button" id="stats-btn" class="btn btn--ghost">Stats</button>
          <button type="button" id="theme-btn" class="btn">Toggle theme</button>
        </nav>
      </header>

      <section class="controls">
        <button type="button" id="play-btn" class="btn btn--accent">Play</button>
        <button type="button" id="hint-btn" class="btn btn--ghost">Hint</button>
        <div class="controls__meta" role="status" aria-live="polite">
          <span id="puzzle-label"></span>
          <span id="puzzle-date"></span>
          <span id="streak-flair" class="streak-flair" aria-live="polite"></span>
        </div>
        <div class="mode-toggle" role="radiogroup" aria-label="Puzzle mode">
          <button type="button" data-mode="daily" class="chip">Daily</button>
          <button type="button" data-mode="random" class="chip">Random</button>
        </div>
      </section>

      <section class="definition" aria-live="polite">
        <h2>Definition</h2>
        <p id="definition-text"></p>
      </section>

      <div id="message" class="message" role="status" aria-live="polite" data-testid="message"></div>

      <input id="key-capture" type="text" aria-hidden="true" autocomplete="off" autocapitalize="characters" spellcheck="false" />

      <section id="grid" class="grid" role="grid" aria-label="Guess grid" data-testid="grid"></section>

      <section id="keyboard" class="keyboard" aria-label="On-screen keyboard" data-testid="keyboard"></section>

      <section class="scoreboard" aria-label="Player stats">
        <div class="score">
          <span class="score__label">Score</span>
          <span id="score-total" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Played</span>
          <span id="score-played" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Wins</span>
          <span id="score-won" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Streak</span>
          <span id="score-streak" class="score__value">0</span>
        </div>
        <div class="score">
          <span class="score__label">Best</span>
          <span id="score-best" class="score__value">0</span>
        </div>
      </section>

      <footer class="footer">
        <div class="footer__instructions"></div>
        <div class="footer__attribution">
          <div><a href="https://github.com/adilio/cyberdle" target="_blank" rel="noopener" class="footer__link">View on GitHub</a></div>
          <div>Made with 💜 by <a href="https://github.com/adilio" target="_blank" rel="noopener" class="footer__link">Adil Leghari</a></div>
        </div>
      </footer>
    </div>

    <dialog id="help-dialog" class="modal">
      <form method="dialog">
        <header class="modal__header">
          <h2>How to play</h2>
          <button class="btn btn--ghost" value="cancel">Close</button>
        </header>
        <div class="modal__body">
          <p>Guess the cybersecurity acronym that matches the definition in six tries.</p>
          <ul>
            <li>Letters turn green when correct, yellow when present elsewhere, gray otherwise.</li>
            <li>Only approved acronyms are accepted. Length must match the target.</li>
            <li>Daily mode picks a deterministic acronym; Random gives a new puzzle each time.</li>
          </ul>
        </div>
      </form>
    </dialog>

    <div id="confetti" aria-hidden="true"></div>

    <dialog id="stats-dialog" class="modal">
      <form method="dialog">
        <header class="modal__header">
          <h2>Statistics</h2>
          <button class="btn btn--ghost" value="cancel">Close</button>
        </header>
        <div class="modal__body">
          <p><strong>Score:</strong> <span id="modal-score">0</span></p>
          <p><strong>Played:</strong> <span id="modal-played">0</span></p>
          <p><strong>Win %:</strong> <span id="modal-win-percent">0</span></p>
          <p><strong>Current streak:</strong> <span id="modal-streak">0</span></p>
          <p><strong>Best streak:</strong> <span id="modal-best">0</span></p>
        </div>
      </form>
    </dialog>

    <div id="result-dialog" class="modal modal--result" role="dialog" aria-modal="true" aria-hidden="true" tabindex="-1">
      <div class="modal__surface">
        <header class="modal__header">
          <h2 id="result-title">Nice work!</h2>
          <button type="button" class="btn btn--ghost" data-close-result>Close</button>
        </header>
        <div class="modal__body">
          <p id="result-message"></p>
          <p id="result-hint-note" style="font-size:0.9em;opacity:0.8;display:none;"></p>
          <p><strong>Acronym:</strong> <span id="result-word"></span></p>
          <p><strong>Expansion:</strong> <span id="result-expansion"></span></p>
          <p><strong>Definition:</strong> <span id="result-definition"></span></p>
          <div class="modal__actions">
            <button type="button" class="btn" id="result-share">Share</button>
            <button type="button" class="btn" id="result-copy">Copy</button>
            <button type="button" class="btn btn--accent" id="result-play-again">Play again</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      let dataset = [];
      let wordList = [];

      const SCORE_TABLE = [100, 80, 60, 40, 20, 10];
      const MAX_ATTEMPTS = 6;
      const STORAGE_KEYS = {
        game: 'cyberdle:simple:game',
        stats: 'cyberdle:simple:stats',
        theme: 'cyberdle:simple:theme',
        mode: 'cyberdle:simple:mode'
      };

      const root = document.documentElement;
      const gridEl = document.getElementById('grid');
      const messageEl = document.getElementById('message');
      const definitionEl = document.getElementById('definition-text');
      const puzzleLabelEl = document.getElementById('puzzle-label');
      const puzzleDateEl = document.getElementById('puzzle-date');
      const scoreTotalEl = document.getElementById('score-total');
      const scorePlayedEl = document.getElementById('score-played');
      const scoreWonEl = document.getElementById('score-won');
      const scoreStreakEl = document.getElementById('score-streak');
      const scoreBestEl = document.getElementById('score-best');
      const streakFlairEl = document.getElementById('streak-flair');
      const modalScoreEl = document.getElementById('modal-score');
      const modalPlayedEl = document.getElementById('modal-played');
      const modalWinPercentEl = document.getElementById('modal-win-percent');
      const modalStreakEl = document.getElementById('modal-streak');
      const modalBestEl = document.getElementById('modal-best');
      const helpDialog = document.getElementById('help-dialog');
      const statsDialog = document.getElementById('stats-dialog');
      const resultDialog = document.getElementById('result-dialog');
      const resultTitleEl = document.getElementById('result-title');
      const resultMessageEl = document.getElementById('result-message');
      const resultWordEl = document.getElementById('result-word');
      const resultExpansionEl = document.getElementById('result-expansion');
      const resultDefinitionEl = document.getElementById('result-definition');
      const resultPlayAgainBtn = document.getElementById('result-play-again');
      const resultCloseBtn = document.querySelector('[data-close-result]');
      const themeBtn = document.getElementById('theme-btn');
      const confettiRoot = document.getElementById('confetti');
      const helpBtn = document.getElementById('help-btn');
      const statsBtn = document.getElementById('stats-btn');
      const playBtn = document.getElementById('play-btn');
      const hintBtn = document.getElementById('hint-btn');
      const modeButtons = Array.from(document.querySelectorAll('.mode-toggle .chip'));
      const keyboardEl = document.getElementById('keyboard');
      const keyCapture = document.getElementById('key-capture');
      const resultShareBtn = document.getElementById('result-share');
      const resultCopyBtn = document.getElementById('result-copy');
      const resultHintNoteEl = document.getElementById('result-hint-note');

      let tiles = [];
      let currentGuess = '';
      let mode = loadMode();
      let stats = loadStats();
      let theme = loadTheme();
      let session = null;
      const keyboardButtons = new Map();
      const keyboardState = new Map();
      let confettiTimeout = 0;
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      initApp();

      async function initApp() {
        const acronyms = await loadDataset();
        if (!acronyms.length) {
          showDatasetError();
          return;
        }

        dataset = acronyms.map((item) => ({
          word: item.w.toUpperCase(),
          expansion: item.e,
          definition: item.d
        }));
        wordList = dataset.map((item) => item.word);

        session = initSession();
        applyTheme();
        buildGrid(session.len);
        buildKeyboard();
        renderAll();
        attachEvents();
        if ('ontouchstart' in window) {
          tiles.flat().forEach(tile => tile.setAttribute('tabindex', '0'));
        }
        focusKeyCapture();
      }

      function scoreFor(row) {
        return SCORE_TABLE[row - 1] ?? 0;
      }

      function evaluateGuess(target, guess) {
        const t = [...target];
        const g = [...guess];
        const res = Array(t.length).fill('absent');
        const rem = {};
        for (let i = 0; i < t.length; i += 1) {
          if (g[i] === t[i]) {
            res[i] = 'correct';
          } else {
            const char = t[i];
            rem[char] = (rem[char] ?? 0) + 1;
          }
        }
        for (let i = 0; i < t.length; i += 1) {
          if (res[i] === 'correct') continue;
          const char = g[i];
          if (rem[char] && rem[char] > 0) {
            res[i] = 'present';
            rem[char] -= 1;
          }
        }
        return res;
      }

      function isValidGuess(guess, list, len) {
        return /^[A-Z]+$/.test(guess) && guess.length === len;
      }

      function yyyymmddSeed(date = new Date()) {
        return date.getFullYear() * 10000 + (date.getMonth() + 1) * 100 + date.getDate();
      }

      function seededIndex(seed, max) {
        let x = seed | 0;
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        return Math.abs(x) % max;
      }

      function initSession() {
        const stored = loadGame(wordList);
        if (stored) {
          const entry = dataset[stored.index] || dataset.find((item) => item.word === stored.word);
          if (entry) {
            if (stored.mode === 'daily') {
              const daily = getDailyPuzzle();
              if (entry.word === daily.entry.word) {
                return hydrateSession(stored, entry, daily.seed, daily.index);
              }
            } else {
              return hydrateSession(stored, entry, stored.seed, stored.index);
            }
          }
        }
        return createSessionFromPuzzle(mode === 'daily' ? getDailyPuzzle() : getRandomPuzzle(), mode);
      }

      function hydrateSession(stored, entry, seed, index) {
        mode = stored.mode;
        const guesses = stored.guesses.slice(0, MAX_ATTEMPTS).map((x) => x.toUpperCase());
        const results = stored.results.slice(0, MAX_ATTEMPTS);
        return {
          word: entry.word,
          expansion: entry.expansion,
          definition: entry.definition,
          len: entry.word.length,
          guesses,
          results,
          row: Math.max(0, Math.min(MAX_ATTEMPTS - 1, stored.row)),
          done: Boolean(stored.done),
          win: Boolean(stored.win),
          seed,
          index,
          mode,
          hinted: Boolean(stored.hinted)
        };
      }

      function createSession(entry, puzzleMode, index, seed) {
        return {
          word: entry.word,
          expansion: entry.expansion,
          definition: entry.definition,
          len: entry.word.length,
          guesses: Array(MAX_ATTEMPTS).fill(''),
          results: Array(MAX_ATTEMPTS).fill(null),
          row: 0,
          done: false,
          win: false,
          seed,
          index,
          mode: puzzleMode,
          hinted: false
        };
      }

      function getDailyPuzzle() {
        const seed = yyyymmddSeed();
        const index = seededIndex(seed, dataset.length);
        return { entry: dataset[index], index, seed };
      }

      function getRandomPuzzle() {
        const seed = Math.floor(Math.random() * 2 ** 31);
        const index = Math.floor(Math.random() * dataset.length);
        return { entry: dataset[index], index, seed };
      }

      function createSessionFromPuzzle(puzzle, puzzleMode) {
        mode = puzzleMode;
        saveMode(mode);
        stats = loadStats();
        const next = createSession(puzzle.entry, puzzleMode, puzzle.index, puzzle.seed);
        persistSession(next);
        return next;
      }

      function persistSession(state) {
        saveGame({
          version: 1,
          word: state.word,
          definition: state.definition,
          len: state.len,
          guesses: state.guesses,
          results: state.results.map((row) => (row ? [...row] : [])),
          row: state.row,
          done: state.done,
          win: state.win,
          seed: state.seed,
          index: state.index,
          mode: state.mode,
          hinted: Boolean(state.hinted)
        });
      }

      function buildGrid(columns) {
        root.style.setProperty('--cols', String(columns));
        gridEl.innerHTML = '';
        tiles = [];
        for (let row = 0; row < MAX_ATTEMPTS; row += 1) {
          const rowEl = document.createElement('div');
          rowEl.className = 'grid__row';
          rowEl.setAttribute('role', 'row');
          const rowTiles = [];
          for (let col = 0; col < columns; col += 1) {
            const tile = document.createElement('div');
            tile.className = 't';
            tile.setAttribute('role', 'gridcell');
            rowEl.appendChild(tile);
            rowTiles.push(tile);
          }
          gridEl.appendChild(rowEl);
          tiles.push(rowTiles);
        }
      }

      function buildKeyboard() {
        if (!keyboardEl) return;
        keyboardButtons.clear();
        keyboardEl.innerHTML = '';
        const layout = [
          ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
          ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
          ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'BACK']
        ];
        layout.forEach((row) => {
          const rowEl = document.createElement('div');
          rowEl.className = 'keyboard__row';
          row.forEach((key) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'key';
            if (key === 'ENTER') {
              button.dataset.key = 'ENTER';
              button.textContent = 'Enter';
              button.classList.add('key--wide');
            } else if (key === 'BACK') {
              button.dataset.key = 'BACK';
              button.textContent = '⌫';
              button.classList.add('key--wide');
            } else {
              button.dataset.key = key;
              button.textContent = key;
              keyboardButtons.set(key, button);
            }
            rowEl.appendChild(button);
          });
          keyboardEl.appendChild(rowEl);
        });
        keyboardState.clear();
      }

      function renderAll() {
        renderModeButtons();
        renderDefinition();
        renderGrid();
        renderStats();
        updateModalStats();
        updateMeta();
        updateFooter();
        setMessage('');
        updateHintButton();
      }

      function renderModeButtons() {
        modeButtons.forEach((button) => {
          const value = button.dataset.mode === 'random' ? 'random' : 'daily';
          button.dataset.active = value === mode ? 'true' : 'false';
        });
      }

      function renderDefinition() {
        definitionEl.textContent = session.definition;
      }

      function renderGrid() {
        tiles.forEach((rowEl, rowIndex) => {
          const rowContainer = rowEl[0] ? rowEl[0].parentElement : null;
          if (rowContainer) {
            rowContainer.classList.toggle('active', !session.done && session.row === rowIndex);
          }
          rowEl.forEach((tile, colIndex) => {
            const guessLetter = session.guesses[rowIndex]?.[colIndex] ?? '';
            tile.textContent = guessLetter;
            tile.classList.remove('t--correct', 't--present', 't--absent');
            const resultRow = session.results[rowIndex];
            const status = resultRow ? resultRow[colIndex] : undefined;
            if (status === 'correct') tile.classList.add('t--correct');
            else if (status === 'present') tile.classList.add('t--present');
            else if (status === 'absent') tile.classList.add('t--absent');
          });
        });
        if (!session.done) {
          const rowIndex = session.row;
          tiles[rowIndex].forEach((tile, colIndex) => {
            tile.textContent = currentGuess[colIndex] ?? '';
          });
        }
        refreshKeyboardFromSession();
      }

      function renderStats() {
        scoreTotalEl.textContent = String(stats.score);
        scorePlayedEl.textContent = String(stats.played);
        scoreWonEl.textContent = String(stats.won);
        scoreStreakEl.textContent = String(stats.streak);
        scoreBestEl.textContent = String(stats.best);
        updateStreakFlair();
      }

      function updateModalStats() {
        modalScoreEl.textContent = String(stats.score);
        modalPlayedEl.textContent = String(stats.played);
        const winPercent = stats.played === 0 ? 0 : Math.round((stats.won / stats.played) * 100);
        modalWinPercentEl.textContent = String(winPercent);
        modalStreakEl.textContent = String(stats.streak);
        modalBestEl.textContent = String(stats.best);
      }

      function updateMeta() {
        puzzleLabelEl.textContent = `Puzzle #${session.index + 1}`;
        puzzleDateEl.textContent = mode === 'daily' ? new Date().toLocaleDateString() : 'Random challenge';
      }

      function updateFooter() {
        const instructionsEl = document.querySelector('.footer__instructions');
        if (!instructionsEl) return;
        const isTouch = 'ontouchstart' in window;
        instructionsEl.textContent = isTouch
          ? 'Use the on-screen keyboard or type in the input below. Enter submits.'
          : 'Type with your keyboard. Enter submits. Backspace deletes.';
      }

      function setMessage(message, tone = 'info') {
        messageEl.textContent = message;
        messageEl.dataset.tone = tone;
      }

      function attachEvents() {
        const isTouch = 'ontouchstart' in window;
        if (isTouch) {
          // Use input events for mobile instead of keydown for better compatibility
          keyCapture.addEventListener('input', handleMobileInput);
          keyCapture.addEventListener('keydown', handleMobileKeydown);
          keyCapture.addEventListener('compositionstart', handleCompositionStart);
          keyCapture.addEventListener('compositionend', handleCompositionEnd);
          gridEl.addEventListener('click', (event) => {
            if (event.target.classList.contains('t') && !session.done) {
              focusKeyCapture();
            }
          });
        } else {
          window.addEventListener('keydown', handleKeydown);
        }
        themeBtn.addEventListener('click', handleThemeToggle);
        helpBtn.addEventListener('click', () => helpDialog.showModal());
        statsBtn.addEventListener('click', () => {
          updateModalStats();
          statsDialog.showModal();
        });
        helpDialog.addEventListener('close', focusKeyCapture);
        statsDialog.addEventListener('close', focusKeyCapture);
        if (resultCloseBtn) {
          resultCloseBtn.addEventListener('click', () => {
            forceCloseResultDialog();
          });
        }
        const resultSurface = resultDialog.querySelector('.modal__surface');
        if (resultSurface) {
          resultSurface.addEventListener('click', (event) => event.stopPropagation());
        }
        resultDialog.addEventListener('click', (event) => {
          if (event.target === resultDialog) {
            forceCloseResultDialog();
          }
        });
        keyboardEl.addEventListener('click', handleKeyboardClick);
        playBtn.addEventListener('click', () => startNewGame(mode));
        modeButtons.forEach((button) => {
          button.addEventListener('click', () => {
            const nextMode = button.dataset.mode === 'random' ? 'random' : 'daily';
            if (mode === nextMode) return;
            mode = nextMode;
            saveMode(mode);
            startNewGame(mode);
            renderModeButtons();
          });
        });
        resultPlayAgainBtn.addEventListener('click', () => {
          forceCloseResultDialog();
          startNewGame(mode);
        });
        if (hintBtn) {
          hintBtn.addEventListener('click', handleHintClick);
        }
        if (resultShareBtn) {
          resultShareBtn.addEventListener('click', handleShareClick);
        }
        if (resultCopyBtn) {
          resultCopyBtn.addEventListener('click', handleCopyClick);
        }
        keyCapture.addEventListener('blur', focusKeyCapture);
      }

      async function loadDataset() {
        if (Array.isArray(window.CYBERDLE_DATA)) {
          return window.CYBERDLE_DATA;
        }
        console.error('CYBERDLE_DATA not found – ensure acronyms.js loads before index.html.');
        return [];
      }

      function launchConfetti() {
        if (!confettiRoot || prefersReducedMotion) return;

        stopConfetti();
        const colors = ['#00cc66', '#ffd966', '#0f9347', '#65e088'];
        const total = 140;
        const frag = document.createDocumentFragment();

        for (let i = 0; i < total; i += 1) {
          const piece = document.createElement('span');
          piece.className = 'confetti-piece';
          piece.style.left = `${Math.random() * 100}%`;
          piece.style.setProperty('--dx', `${(Math.random() - 0.5) * 40}vw`);
          piece.style.setProperty('--rot', `${Math.random() * 720 - 360}deg`);
          piece.style.setProperty('--dur', `${1.2 + Math.random() * 0.6}s`);
          piece.style.setProperty('--delay', `${Math.random() * 0.2}s`);
          piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          frag.appendChild(piece);
        }

        confettiRoot.appendChild(frag);
        confettiRoot.dataset.active = 'true';

        confettiTimeout = window.setTimeout(() => stopConfetti(), 1800);
      }

      function stopConfetti() {
        if (!confettiRoot) return;
        window.clearTimeout(confettiTimeout);
        confettiRoot.dataset.active = 'false';
        confettiRoot.innerHTML = '';
      }

      function forceCloseResultDialog() {
        // Remove modal-active class from body and html
        document.documentElement.classList.remove('modal-active');
        document.body.classList.remove('modal-active');

        resultDialog.classList.remove('is-open');
        resultDialog.setAttribute('aria-hidden', 'true');

        // Force hide the modal by setting display to none
        resultDialog.style.display = 'none';

        // Also reset the backdrop opacity using CSS custom properties
        resultDialog.style.setProperty('--modal-backdrop-opacity', '0');
        resultDialog.style.position = '';
        resultDialog.style.inset = '';
        resultDialog.style.top = '';
        resultDialog.style.left = '';
        resultDialog.style.width = '';
        resultDialog.style.height = '';
        resultDialog.style.zIndex = '';
        resultDialog.style.justifyContent = '';
        resultDialog.style.alignItems = '';
        resultDialog.style.background = '';
        resultDialog.style.boxSizing = '';

        // Also try to close using native dialog method
        try {
          if (resultDialog.close) {
            resultDialog.close();
          }
        } catch (e) {
          // Ignore errors if dialog is already closed
        }

        stopConfetti();
        if (resultHintNoteEl) {
          resultHintNoteEl.textContent = '';
          resultHintNoteEl.style.display = 'none';
        }
        focusKeyCapture();
      }

      function showDatasetError() {
        setMessage('Unable to load the acronym list. Ensure `acronyms.js` sits next to `index.html`.', 'error');
        definitionEl.textContent = 'Missing dataset file.';
        puzzleLabelEl.textContent = '';
        puzzleDateEl.textContent = '';
        gridEl.innerHTML = '';
        keyboardEl.innerHTML = '';
        [playBtn, themeBtn, helpBtn, statsBtn, resultPlayAgainBtn, ...modeButtons].forEach((el) => {
          if (el) el.disabled = true;
        });
      }

      function focusKeyCapture() {
        if (!session.done) {
          // Ensure input is properly set for mobile
          keyCapture.value = currentGuess || ' ';
          keyCapture.focus({ preventScroll: true });
          // Set cursor to end for better UX
          setTimeout(() => {
            const pos = keyCapture.value.length;
            keyCapture.setSelectionRange(pos, pos);
          }, 0);
        }
      }

      function handleHintClick() {
        if (!hintBtn || session.done) return;
        session.hinted = true;
        persistSession(session);
        const hint = `First letter: ${session.word[0]} • Length: ${session.len}`;
        setMessage(hint, 'info');
        updateHintButton();
        focusKeyCapture();
      }

      function updateHintButton() {
        if (!hintBtn) return;
        hintBtn.disabled = session.done;
      }

      function updateStreakFlair() {
        if (!streakFlairEl) return;
        const streak = stats.streak;
        if (!streak) {
          streakFlairEl.textContent = '';
          streakFlairEl.style.display = 'none';
          streakFlairEl.classList.remove('hot');
          return;
        }
        let icon = '⭐';
        if (streak >= 10) icon = '🔥';
        else if (streak >= 5) icon = '⚡';
        streakFlairEl.textContent = `${icon} ${streak}`;
        streakFlairEl.style.display = 'inline-flex';
      }

      function animateStreakFlair() {
        if (!streakFlairEl || streakFlairEl.style.display === 'none') return;
        streakFlairEl.classList.remove('hot');
        // Force reflow to restart animation
        // eslint-disable-next-line no-unused-expressions
        streakFlairEl.offsetHeight;
        streakFlairEl.classList.add('hot');
      }

      function handleThemeToggle() {
        theme = theme === 'dark' ? 'light' : 'dark';
        applyTheme();
        saveTheme(theme);
      }

      function applyTheme() {
        root.setAttribute('data-theme', theme);
      }

      function handleKeydown(event) {
        if (statsDialog.open || helpDialog.open) return;

        if (session.done && event.key === 'Enter') {
          forceCloseResultDialog();
          startNewGame(mode);
          return;
        }

        if (event.key === 'Enter') {
          submitGuess();
        } else if (event.key === 'Backspace') {
          removeLetter();
        } else {
          const letter = event.key.toUpperCase();
          if (/^[A-Z]$/.test(letter)) {
            addLetter(letter);
          }
        }
      }

      let isComposing = false;

      function handleMobileInput(event) {
        if (isComposing || statsDialog.open || helpDialog.open) return;

        const newValue = event.target.value.toUpperCase();
        const currentLength = currentGuess.length;
        const newLength = newValue.length;

        // Handle backspace (shorter input)
        if (newLength < currentLength) {
          const charsToRemove = currentLength - newLength;
          for (let i = 0; i < charsToRemove; i++) {
            removeLetter();
          }
        }
        // Handle new characters (longer input)
        else if (newLength > currentLength) {
          const newChars = newValue.slice(currentLength);
          for (const char of newChars) {
            if (/^[A-Z]$/.test(char)) {
              addLetter(char);
            }
          }
        }

        event.target.value = currentGuess;
      }

      function handleCompositionStart() {
        isComposing = true;
      }

      function handleCompositionEnd(event) {
        isComposing = false;
        // Process the composed text
        const composedText = event.data.toUpperCase();
        for (const char of composedText) {
          if (/^[A-Z]$/.test(char)) {
            addLetter(char);
          }
        }
        keyCapture.value = currentGuess;
      }

      function handleMobileKeydown(event) {
        if (statsDialog.open || helpDialog.open) return;
        if (session.done && event.key === 'Enter') {
          forceCloseResultDialog();
          startNewGame(mode);
          return;
        }
        if (event.key === 'Enter') {
          submitGuess();
          event.preventDefault();
        } else if (event.key === 'Backspace') {
          removeLetter();
          event.preventDefault();
        }
        // Let input event handle regular character input
        keyCapture.value = currentGuess;
      }

      function handleKeyboardClick(event) {
        const target = event.target;
        if (!(target instanceof HTMLButtonElement)) return;
        const key = target.dataset.key;
        if (!key) return;
        if (key === 'ENTER') {
          submitGuess();
        } else if (key === 'BACK') {
          removeLetter();
        } else {
          addLetter(key);
        }
        focusKeyCapture();
      }

      function addLetter(letter) {
        if (session.done) return;
        if (currentGuess.length >= session.len) return;
        currentGuess += letter;
        renderGrid();
      }

      function removeLetter() {
        if (session.done) return;
        currentGuess = currentGuess.slice(0, -1);
        renderGrid();
      }

      function submitGuess() {
        if (session.done) {
          const attempts = session.results.filter(Boolean).length || session.row + 1;
          showResultDialog(session.win, session.win ? attempts : MAX_ATTEMPTS);
          return;
        }
        if (currentGuess.length !== session.len) {
          setMessage('Not enough letters', 'error');
          return;
        }
        if (!isValidGuess(currentGuess, wordList, session.len)) {
          setMessage('Letters only (A–Z).', 'error');
          return;
        }
        handleGuess(currentGuess);
      }

      function handleGuess(guess) {
        const rowIndex = session.row;
        const evaluation = evaluateGuess(session.word, guess);
        session.guesses[rowIndex] = guess;
        session.results[rowIndex] = evaluation;
        updateKeyboardWithGuess(guess, evaluation);
        renderGrid();

        if (evaluation.every((tile) => tile === 'correct')) {
          session.done = true;
          session.win = true;
          stats = applyWin(stats, rowIndex);
          persistSession(session);
          saveStats(stats);
          renderStats();
          updateModalStats();
          setMessage(`Solved in ${rowIndex + 1} ${rowIndex === 0 ? 'try' : 'tries'}!`, 'success');

          // Launch confetti immediately
          launchConfetti();
          animateStreakFlair();

          // Delay modal appearance to let confetti be visible
          setTimeout(() => {
            showResultDialog(true, rowIndex + 1);
          }, 500); // 0.5 second delay to enjoy the confetti

            return;
          }

        if (rowIndex === MAX_ATTEMPTS - 1) {
          session.done = true;
          session.win = false;
          stats = applyLoss(stats);
          persistSession(session);
          saveStats(stats);
          renderStats();
          updateModalStats();
          setMessage(`Out of tries! The word was ${session.word}.`, 'error');
          showResultDialog(false, MAX_ATTEMPTS);
          return;
        }

        session.row += 1;
        currentGuess = '';
        persistSession(session);
        renderGrid();
        setMessage('');
      }

      function updateKeyboardWithGuess(guess, evaluation) {
        guess.split('').forEach((letter, index) => {
          const next = evaluation[index];
          const merged = mergeTileState(keyboardState.get(letter), next);
          keyboardState.set(letter, merged);
          const button = keyboardButtons.get(letter);
          if (button) {
            button.dataset.state = merged;
          }
        });
      }

      function refreshKeyboardFromSession() {
        keyboardButtons.forEach((button) => {
          delete button.dataset.state;
        });
        keyboardState.clear();
        session.results.forEach((result, idx) => {
          if (!result) return;
          const guess = session.guesses[idx];
          if (!guess) return;
          updateKeyboardWithGuess(guess, result);
        });
      }

      function mergeTileState(previous, next) {
        if (!previous) return next;
        const priority = { correct: 3, present: 2, absent: 1 };
        return priority[next] >= priority[previous] ? next : previous;
      }

      const WIN_TITLES = [
        'You cracked it!',
        'Cyber sleuth!',
        'Mission accomplished!',
        'Zero-day wizardry!',
        'Security star!',
        'Threat neutralized!',
        'Legendary analyst!',
        'Perimeter breached!',
        'Firewall of fame!',
        'Acronym assassin!',
        'Defense in depth master!',
        'SOC hero!',
        'Crypto champ!',
        'Nailed the signal!',
        'Own the incident!'
      ];

      function randomWinTitle() {
        if (!WIN_TITLES.length) return 'You cracked it!';
        const now = Date.now();
        const idx = Math.abs((now ^ (now >>> 7) ^ (now << 3))) % WIN_TITLES.length;
        return WIN_TITLES[idx];
      }

      function showResultDialog(win, attempts) {
        resultTitleEl.textContent = win ? randomWinTitle() : 'Good effort!';
        resultMessageEl.textContent = win
          ? `Solved in ${attempts} ${attempts === 1 ? 'try' : 'tries'}.`
          : `The answer was ${session.word}.`;
        if (resultHintNoteEl) {
          if (win && session.hinted) {
            resultHintNoteEl.textContent = '(Hint used: -20 points)';
            resultHintNoteEl.style.display = 'block';
          } else {
            resultHintNoteEl.textContent = '';
            resultHintNoteEl.style.display = 'none';
          }
        }
        resultWordEl.textContent = session.word;
        resultExpansionEl.textContent = session.expansion;
        resultDefinitionEl.textContent = session.definition;

        document.body.classList.add('modal-active');
        resultDialog.classList.add('is-open');
        resultDialog.setAttribute('aria-hidden', 'false');

        // Use native dialog method with fallback
        try {
          resultDialog.showModal();
        } catch (e) {
          // Fallback for browsers that don't support showModal
          resultDialog.style.display = 'flex';
          resultDialog.style.position = 'fixed';
          resultDialog.style.inset = '0';
          resultDialog.style.width = '100vw';
          resultDialog.style.height = '100vh';
          resultDialog.style.zIndex = '999999';
          resultDialog.style.justifyContent = 'center';
          resultDialog.style.alignItems = 'center';
          resultDialog.style.background = 'transparent';
          resultDialog.style.boxSizing = 'border-box';
        }

        if (resultCloseBtn) {
          setTimeout(() => resultCloseBtn.focus({ preventScroll: true }), 100);
        }
      }

      function applyWin(snapshot, rowIndex) {
        const baseScore = scoreFor(rowIndex + 1);
        const penalty = session && session.hinted ? 20 : 0;
        const finalScore = Math.max(0, baseScore - penalty);
        return {
          version: 1,
          played: snapshot.played + 1,
          won: snapshot.won + 1,
          streak: snapshot.streak + 1,
          best: Math.max(snapshot.best, snapshot.streak + 1),
          score: snapshot.score + finalScore
        };
      }

      function applyLoss(snapshot) {
        return {
          version: 1,
          played: snapshot.played + 1,
          won: snapshot.won,
          streak: 0,
          best: snapshot.best,
          score: snapshot.score
        };
      }

      function generateShareText() {
        if (!session || !session.done) return '';
        const filledRows = session.results.filter((row) => Array.isArray(row) && row.length);
        const attempts = filledRows.length || session.row + 1;
        const emoji = session.win ? attempts : 'X';
        const hintSuffix = session.hinted && session.win ? ' • Hint used' : '';
        const header = `Cyberdle #${session.index + 1} ${emoji}/${MAX_ATTEMPTS}${hintSuffix}`;
        const attemptSummary = session.win
          ? `Solved in ${attempts} ${attempts === 1 ? 'try' : 'tries'}`
          : `Missed it — answer: ${session.word}`;
        const winPercent = stats.played === 0 ? 0 : Math.round((stats.won / stats.played) * 100);
        const summary = `Score ${stats.score} • Win ${winPercent}% • Streak ${stats.streak}`;
        const grid = filledRows
          .map((row) => row
            .map((state) => {
              if (state === 'correct') return '🟩';
              if (state === 'present') return '🟨';
              return '⬛';
            })
            .join(''))
          .join('\n');
        const url = `${window.location.origin}${window.location.pathname}`;
        const lines = ['My Cyberdle Result', header, attemptSummary, summary];
        if (grid) {
          lines.push(grid, '');
        }
        lines.push('Your turn! Try Cyberdle at:', url);
        return lines.join('\n');
      }

      function collectShareRows() {
        if (!session) return [];
        return session.results
          .map((row, idx) => ({
            states: Array.isArray(row) && row.length ? row : null,
            guess: session.guesses[idx] || ''
          }))
          .filter((entry) => entry.states);
      }

      function readColor(styles, name, fallback) {
        const value = styles.getPropertyValue(name);
        return value && value.trim() ? value.trim() : fallback;
      }

      function drawRoundedRect(ctx, x, y, width, height, radius) {
        const r = Math.max(0, Math.min(radius, width / 2, height / 2));
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function canvasToBlob(canvas) {
        return new Promise((resolve) => {
          if (canvas.toBlob) {
            canvas.toBlob((blob) => resolve(blob), 'image/png', 1);
            return;
          }
          const dataUrl = canvas.toDataURL('image/png');
          const base64 = dataUrl.split(',')[1];
          if (!base64) {
            resolve(null);
            return;
          }
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i += 1) {
            bytes[i] = binary.charCodeAt(i);
          }
          resolve(new Blob([bytes], { type: 'image/png' }));
        });
      }

      async function createShareCard() {
        if (!session || !session.done) return null;
        const rows = collectShareRows();
        if (!rows.length) return null;

        const width = 880;
        const height = 520;
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        if (!ctx) return null;

        const styles = getComputedStyle(document.documentElement);
        const surface = readColor(styles, '--surface', '#0f2520');
        const fg = readColor(styles, '--fg', '#f1fff9');
        const accent = readColor(styles, '--accent', '#2ee89e');
        const muted = readColor(styles, '--muted', '#7ba79a');
        const correctColor = readColor(styles, '--t-correct', '#21c262');
        const presentColor = readColor(styles, '--t-present', '#d5b63f');
        const absentColor = readColor(styles, '--t-absent', '#1f332f');

        ctx.fillStyle = surface;
        ctx.fillRect(0, 0, width, height);
        ctx.save();
        ctx.globalAlpha = 0.24;
        ctx.fillStyle = accent;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();

        ctx.fillStyle = fg;
        ctx.font = '700 48px "Inter", "Segoe UI", sans-serif';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(`Cyberdle #${session.index + 1}`, 48, 96);

        const attemptCount = rows.length || session.row + 1;
        const modeLabel = mode === 'daily' ? 'Daily challenge' : 'Random challenge';
        const attemptLabel = session.win
          ? `Solved in ${attemptCount} ${attemptCount === 1 ? 'try' : 'tries'}`
          : 'Missed it today';
        const hintLabel = session.hinted ? ' • Hint used (-20)' : '';
        ctx.font = '500 26px "Inter", "Segoe UI", sans-serif';
        ctx.fillText(`${modeLabel} • ${attemptLabel}${hintLabel}`, 48, 146);

        const tileGap = 12;
        const maxCols = Math.max(session.len, 3);
        let tileSize = Math.max(44, Math.min(72, Math.floor((width - 96 - tileGap * (maxCols - 1)) / maxCols)));
        const topMargin = 190;
        const bottomMargin = 180;
        const availableHeight = height - topMargin - bottomMargin;
        if (rows.length > 0) {
          const maxRowTile = Math.floor((availableHeight - tileGap * (rows.length - 1)) / rows.length);
          if (maxRowTile > 0) {
            tileSize = Math.min(tileSize, maxRowTile);
          }
        }
        const gridWidth = session.len * tileSize + Math.max(0, session.len - 1) * tileGap;
        const gridHeight = rows.length ? (rows.length * tileSize + Math.max(0, rows.length - 1) * tileGap) : 0;
        const startX = Math.max(48, Math.floor((width - gridWidth) / 2));
        const startY = topMargin + Math.max(0, Math.floor((availableHeight - gridHeight) / 2));

        rows.forEach((entry, rowIndex) => {
          entry.states.forEach((state, colIndex) => {
            const x = startX + colIndex * (tileSize + tileGap);
            const y = startY + rowIndex * (tileSize + tileGap);
            const color = state === 'correct' ? correctColor : state === 'present' ? presentColor : absentColor;
            ctx.fillStyle = color;
            drawRoundedRect(ctx, x, y, tileSize, tileSize, 14);
            ctx.fill();
          });
        });

        const winPercent = stats.played === 0 ? 0 : Math.round((stats.won / stats.played) * 100);
        const summary = `Score ${stats.score} • Win ${winPercent}% • Streak ${stats.streak}`;
        ctx.textAlign = 'start';
        ctx.textBaseline = 'alphabetic';
        ctx.fillStyle = muted;
        ctx.font = '500 24px "Inter", "Segoe UI", sans-serif';
        const summaryY = height - 110;
        ctx.fillText(summary, 48, summaryY);

        ctx.fillStyle = accent;
        ctx.font = '600 22px "Inter", "Segoe UI", sans-serif';
        const url = `${window.location.origin}${window.location.pathname}`;
        ctx.fillText(url, 48, height - 60);

        const blob = await canvasToBlob(canvas);
        if (!blob) return null;
        return { blob, fileName: `cyberdle-${session.index + 1}.png` };
      }

      async function buildSharePayload() {
        if (!session || !session.done) return null;
        const text = generateShareText();
        if (!text) return null;
        const card = await createShareCard();
        let file = null;
        if (card && typeof File !== 'undefined') {
          try {
            file = new File([card.blob], card.fileName, { type: 'image/png' });
          } catch (error) {
            file = null;
          }
        }
        return { text, card, file };
      }

      async function copySharePayload(payload) {
        if (!payload || !navigator.clipboard) return 'none';
        if (window.ClipboardItem && payload.card?.blob && navigator.clipboard.write) {
          try {
            const items = {
              'image/png': payload.card.blob,
              'text/plain': new Blob([payload.text], { type: 'text/plain' })
            };
            await navigator.clipboard.write([new ClipboardItem(items)]);
            return 'card';
          } catch (error) {
            // fall back to text copy below
          }
        }
        try {
          await navigator.clipboard.writeText(payload.text);
          return 'text';
        } catch (error) {
          return 'none';
        }
      }

      async function handleShareClick() {
        const payload = await buildSharePayload();
        if (!payload) {
          setMessage('Nothing to share yet.', 'error');
          return;
        }
        if (navigator.share) {
          const shareData = { text: payload.text, title: 'My Cyberdle Result' };
          if (payload.file && navigator.canShare && navigator.canShare({ files: [payload.file] })) {
            shareData.files = [payload.file];
          }
          try {
            await navigator.share(shareData);
            return;
          } catch (error) {
            if (error && error.name === 'AbortError') {
              return; // user cancelled
            }
            // fall through to clipboard
          }
        }
        const copied = await copySharePayload(payload);
        if (copied === 'card') {
          setMessage('Share card copied to clipboard!', 'success');
        } else if (copied === 'text') {
          setMessage('Share text copied to clipboard!', 'success');
        } else {
          setMessage('Could not share', 'error');
        }
      }

      async function handleCopyClick() {
        const payload = await buildSharePayload();
        if (!payload) {
          setMessage('Nothing to copy yet.', 'error');
          return;
        }
        const copied = await copySharePayload(payload);
        if (copied === 'card') {
          setMessage('Share card copied to clipboard!', 'success');
        } else if (copied === 'text') {
          setMessage('Share text copied to clipboard!', 'success');
        } else {
          setMessage('Could not copy', 'error');
        }
      }

      function startNewGame(nextMode) {
        // Force close any open modals before starting new game
        forceCloseResultDialog();

        currentGuess = '';
        const puzzle = nextMode === 'daily' ? getDailyPuzzle() : getRandomPuzzle();
        session = createSessionFromPuzzle(puzzle, nextMode);
        buildGrid(session.len);
        buildKeyboard();
        renderAll();
        focusKeyCapture();
      }

      function safeParse(value) {
        if (!value) return null;
        try {
          return JSON.parse(value);
        } catch (error) {
          console.warn('Failed to parse storage value', error);
          return null;
        }
      }

      function loadGame(expectedWordList) {
        if (typeof window === 'undefined') return null;
        const raw = safeParse(localStorage.getItem(STORAGE_KEYS.game));
        if (!raw || raw.version !== 1) return null;
        if (!expectedWordList.includes(raw.word)) return null;
        if (raw.len !== raw.word.length) return null;
        if (!Array.isArray(raw.guesses) || !Array.isArray(raw.results)) return null;
        const guesses = raw.guesses.slice(0, MAX_ATTEMPTS).map((g) => (typeof g === 'string' ? g : ''));
        const results = raw.results.slice(0, MAX_ATTEMPTS).map((row) => (Array.isArray(row) ? row : []));
        return {
          version: 1,
          word: raw.word,
          definition: raw.definition,
          len: raw.len,
          guesses,
        results,
        row: Number.isFinite(raw.row) ? Math.max(0, Math.min(MAX_ATTEMPTS - 1, Math.floor(raw.row))) : 0,
        done: Boolean(raw.done),
        win: Boolean(raw.win),
        seed: Number.isFinite(raw.seed) ? Math.floor(raw.seed) : 0,
        index: Number.isFinite(raw.index) ? Math.floor(raw.index) : 0,
        mode: raw.mode === 'random' ? 'random' : 'daily',
        hinted: Boolean(raw.hinted)
      };
      }

      function saveGame(state) {
        localStorage.setItem(STORAGE_KEYS.game, JSON.stringify(state));
      }

      function loadStats() {
        const raw = safeParse(localStorage.getItem(STORAGE_KEYS.stats));
        if (!raw || raw.version !== 1) return createInitialStats();
        return {
          version: 1,
          played: sanitizeNumber(raw.played),
          won: sanitizeNumber(raw.won),
          streak: sanitizeNumber(raw.streak),
          best: sanitizeNumber(raw.best),
          score: sanitizeNumber(raw.score)
        };
      }

      function saveStats(snapshot) {
        localStorage.setItem(STORAGE_KEYS.stats, JSON.stringify(snapshot));
      }

      function createInitialStats() {
        return { version: 1, played: 0, won: 0, streak: 0, best: 0, score: 0 };
      }

      function sanitizeNumber(value) {
        return Number.isFinite(value) ? Math.max(0, Math.floor(value)) : 0;
      }

      function loadTheme() {
        const raw = localStorage.getItem(STORAGE_KEYS.theme);
        return raw === 'light' ? 'light' : 'dark';
      }

      function saveTheme(next) {
        localStorage.setItem(STORAGE_KEYS.theme, next);
      }

      function loadMode() {
        const raw = localStorage.getItem(STORAGE_KEYS.mode);
        return raw === 'random' ? 'random' : 'daily';
      }

      function saveMode(nextMode) {
        localStorage.setItem(STORAGE_KEYS.mode, nextMode);
      }

      /* ============== Test hooks for debugging ============== */
      window.CYBERDLE = {
        _getSession: () => session,
        _getStats: () => stats,
        _startNewGame: (mode) => startNewGame(mode || 'daily')
      };
    </script>
    <!-- Cloudflare Web Analytics -->
    <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "274ecb50b63542d699763b3aaf40e79e"}'>
    </script>
    <!-- End Cloudflare Web Analytics -->
  </body>
</html>
